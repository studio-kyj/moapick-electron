import { app, BrowserWindow, ipcMain } from "electron";
import Nedb from "nedb";
import { v4 as uuidv4 } from "uuid";
import path from "path";
import os from "os";
import fs from "fs";
import iconv from "iconv-lite";
import crawling from "./crawling";
import axios, { AxiosResponse } from "axios";
import { Client } from "pg";
import { User } from "./entities/user.entity";
import { Company } from "./entities/company.entity";
import config from "../ormconfig";
import { DataSource, Repository } from "typeorm";
import "reflect-metadata";

async function addUser() {
  const myDataSource = new DataSource(config);
  if (!myDataSource.isInitialized) {
    await myDataSource
      .initialize()
      .then(() => {
        console.log("db init success");
      })
      .catch((error) => console.log(error));
  }
  await myDataSource
    .createQueryBuilder()
    .insert()
    .into(User)
    .values({
      email: "test@gmail.com",
      password: "123qwe!!",
      name: "홍길땡",
      phone: "01023021020",
    })
    .execute();
}

addUser();

// const user = userRepository.create({ email: "test@gmail.com",
//   password: "123qwe!!",
//   name: "홍길땡",
//   phone: "01023021020"})
// userRepository.save(user)
// const user = new User
// user.email = "test@gmail.com",
// user.password= "123qwe!!",
// user.name= "홍길땡",
// user.phone= "01023021020",
// const userRepository = connection.getRepository(User);
// await userRepository.save(user)

// console.log(users);
//     const user = myDataSource.manager.create(User, {
//   email: "test@gmail.com",
//   password: "123qwe!!",
//   name: "홍길땡",
//   phone: "01023021020",
// });

//     await myDataSource.manager.save(user);
//     console.log("저장완료!");

// saveUser();

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).

declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: false,
      nodeIntegration: true,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

app.whenReady().then(() => {
  createWindow();

  // TypeORM 데이터베이스 연결 (ormconfig.json 사용)
  //  createConnection()
  //  .then(connection => {
  //    console.log("Connected to PostgreSQL");
  //    // 여기서부터 애플리케이션 로직 작성
  //  })
  //  .catch(error => {
  //    console.error("Error connecting to PostgreSQL:", error);
  //  });
});

// onInputValue 이벤트 수신
ipcMain.on("login", async (evt, payload) => {
  console.log("login", payload);
  try {
    const { id, password } = payload;
    const result = await crawling(id, password);

    //TODO: DB에 result 저장
    evt.reply("success", result);
  } catch (error) {
    console.error(error);
  }
});

app.on("window-all-closed", function () {
  if (process.platform !== "darwin") app.quit();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

//Local�� ����
const homedir = os.homedir();
const folderPath = path.join(homedir, "moapick-backdata");

if (!fs.existsSync(folderPath)) {
  fs.mkdirSync(folderPath);
}
//DB 테이블 생성
const db = {
  applicants: new Nedb({
    filename: path.join(folderPath, "applicants.json"),
    autoload: true,
  }),
  users: new Nedb({
    filename: path.join(folderPath, "users.json"),
    autoload: true,
  }),
};
// const id = uuidv4();

//나중에는 users db에서 빼오기
const LOGINID = "sprata111@gamil.com";
const LOGINPASSWORD = "123qwe!!";
const ID = "contact@teamsparta.co";
const PASSWORD = "Tmvkfmxk0423!";
const greetingApiKey =
  "08dacc9b6d4f3ad04f3e31348e1627c69d8883df5eaee04ed3b78a2d8620f65c";
const ID2: string = undefined;
const PASSWORD2: string = undefined;
// const userInfo = {
//   commonId: LOGINID,
//   commonPassword: LOGINPASSWORD,
//   wantedId: ID || null,
//   wantedPassword: PASSWORD || null,
//   greetingApiKey: greetingApiKey || null,
//   programmersId: ID2 || null,
//   programmersPassword: PASSWORD2 || null,
//   createdAt: new Date(),
// };

// 로그인 자리

// db.users.insert(userInfo, (err: any, result: any) => {
//   console.log("===========> ~ result:", result);
//   if (err) {
//     console.log(err);
//   } else {
//     console.log("새로운 지원자 추가완료");
//   }
// });

//★-- ① 크롤링 & DB저장 --★//
// crawlingAndSaveApplicant(ID, PASSWORD); // 크롤링 → 공고아이디(openingId) 통신 및 수신 → 최종 지원자 data form 작성 완료 → local DB 저장
async function crawlingAndSaveApplicant(ID: string, PASSWORD: string) {
  let successCount = 0;
  let failureCount = 0;

  const crawlingData = await crawling(ID, PASSWORD);
  const openedPosts = await getOpeningIdApi();
  for (const data of crawlingData) {
    for (const applicant of data) {
      const title = applicant.position;
      const openingId = await findOpeningId(openedPosts, title);

      const applicantData = {
        isUploaded: false,
        name: applicant.name,
        email: applicant.email,
        phone: applicant.mobile.substr(3),
        openingId: openingId,
        title: applicant.position,
        filename: applicant.file_name,
        fileUrl: applicant.filePath,
        docName: "이력서",
        status: "지원접수",
        application_date: applicant.chk_time,
        referer: "원티드",
        countDownloaded: 0,
        createdAt: new Date(),
        updatedAt: new Date(),
      };
      //--★ DB저장 ★--//
      try {
        await db.applicants.insert(applicantData);
        console.log("새로운 지원자 저장완료");
        successCount++;
      } catch (err) {
        console.log(err);
        failureCount++;
      }
    }
  }

  console.log(`저장 성공: ${successCount}명`);
  console.log(`저장 실패: ${failureCount}명`);
}

async function findOpeningId(responseData: any, title: string) {
  console.log("===========> ~ findOpeningId의 responseData:", responseData);
  // openingId 검색
  const openingInfo = await responseData.find(
    (data: any) => data.title === title
  );
  console.log("===========> ~ openingInfo:", openingInfo);
  console.log("===========> ~ openingInfo.id:", openingInfo.id);
  return openingInfo.id;
}

async function getOpeningIdApi() {
  // openingId 검색에 필요한 자료 가져오기
  const apiUrl = "https://oapi.greetinghr.com/openapi"; //todo: 환경변수처리
  const apiKey =
    "08dacc9b6d4f3ad04f3e31348e1627c69d8883df5eaee04ed3b78a2d8620f65c"; //todo: 환경변수처리
  const page = 0;
  const pageSize = 100;
  const queryParams = `?page=${page}&pageSize=${pageSize}`;
  try {
    const response = await axios.get(
      `${apiUrl}/published-openings${queryParams}`,
      {
        headers: {
          "X-Greeting-OpenAPI": `${apiKey}`,
        },
      }
    );

    const responseData = response.data.data.datas;
    console.log("===========> ~ responseData:", responseData);
    return responseData;
  } catch (err) {
    console.log(err);
  }
}
//-----------------------//

//★-- ② 그리팅 등록 --★//
// register([
//   "VTNC8Qfqie0ywkYo",
//   "4yYC2krwqWAhe7C6",
//   "2SQU5XZuFrSBA1cG",
//   "iAkEa2Mi74OoNzq9",
//   "pM2WjpyoEn3T5Z59",
// ]); //선택적(체크박스) _id 수신

async function register(ids: string[]) {
  await db.users.find({ _id: { $in: ids } }, (err: Error, existUsers: any) => {
    Promise.all(
      existUsers.map((existUser: any) => {
        // console.log("===========> ~ existUser:", existUser);
        // 지원자 openingId 찾기
        const openingId = existUser.openingId;
        // console.log("===========> ~ openingId:", openingId);
        // 저장되는 DATA 빌드
        const applicantData = {
          openingId: openingId,
          name: existUser.name,
          email: existUser.email,
          phone: existUser.phone,
          referer: existUser.referer,
          optionalTermsAgree: existUser.optionalTermsAgree || false,
          documents: [
            {
              fileUrl: existUser.fileUrl,
              filename: existUser.filename,
              fileToken: existUser.fileToken || null,
              docName: existUser.docName,
            },
          ],
          questionnaires: [] as [],
          additionalApplicantInfo: null as null,
        };
        // console.log("===========> ~ applicantData:", applicantData);

        existUser.isUploaded = true;
        existUser.updatedAt = new Date();

        db.users.update(
          { _id: existUser._id },
          existUser,
          {},
          (err: any, numReplaced: number) => {
            if (err) {
              console.error("Update error :", err);
              return;
            }
            console.log(`${numReplaced}번 업데이트 완료`);
          }
        );
      })
    );
  });
}
// // //--모든 정보 불러오기--//
// db.find({},function (err: Error, allApplicantData: any)  {
//   // console.log("===========> ~ result:", allApplicantData);
// })
//★--모든 정보 불러오기--★//
function findAllApplicant() {
  db.applicants.find({}, function (err: Error, allApplicantData: any) {
    console.log("===========> ~ allApplicantData:", allApplicantData);
  });
}
//-----------------------//

// function isUploaded(email: string) {
//   db.find({ email: email }, (err: Error | null, candidates: any[]) => {
//     if (err) {
//       console.error("Find error :", err);
//       return;
//     }

//     if (candidates.length === 0) {
//       console.log(`${email} 이메일 주소를 가진 지원자가 존재하지 않습니다.`);
//       return;
//     }

//     // 'isUploaded' 컬럼의 값을 `true`로 변경하고, 업데이트를 수행합니다.
//     candidates.forEach((candidate) => {
//       const updateData = { $set: { isUploaded: true } };
//       db.update({ _id: candidate._id }, updateData, {}, (err, numReplaced) => {
//         if (err) {
//           console.error("Update error :", err);
//           return;
//         }
//         console.log(`Updated ${numReplaced} document(s).`);
//       });
//     });
//   });
// }

//----------------------------------------------------//
// async function register(email: string) {
//   try {
//     const existUserEmail = await findOneEmail(email);
//     if (!existUserEmail) {
//       throw Error(`${email}은 존재하지 않는 지원자입니다.`);
//     }
//     const existUserString = await readFileAsync(email); // JSON 형식의 문자열
//     const existUser = JSON.parse(existUserString); // JSON 문자열을 객체로 파싱
//     // 지원자 openingId 찾기
//     const openingId = existUser.openingId;
//     console.log("===========> ~ openingId:", openingId);
//     // 저장되는 DATA 빌드
//     const applicantData = {
//       openingId: openingId,
//       name: existUser.name,
//       email: existUser.email,
//       phone: existUser.phone,
//       referer: existUser.referer,
//       optionalTermsAgree: existUser.optionalTermsAgree,
//       documents: [
//         {
//           fileUrl: existUser.fileUrl,
//           filename: existUser.filename,
//           fileToken: existUser.fileToken,
//           docName: existUser.docName,
//         },
//       ],
//       questionnaires: [] as any[],
//       additionalApplicantInfo: null as null,
//     };
//     console.log("===========> ~ applicantData:", applicantData);
//     // const candidates = await this.findCandidates(email); // 후보자 목록 조회
//     // if (candidates.length === 0) {
//     //   console.log(`${email} 이메일 주소를 가진 지원자가 존재하지 않습니다.`);
//     //   return;
//     // }

//     // // 'isUploaded' 컬럼의 값을 `true`로 변경하고, 업데이트를 수행합니다.
//     // candidates.forEach((candidate:any) => {
//     //   const updateData = { $set: { isUploaded: true } };
//     //   db.update({ _id: candidate._id }, updateData, {}, (err, numReplaced) => {
//     //     if (err) {
//     //       console.error("Update error :", err);
//     //       return;
//     //     }
//     //     console.log(`Updated ${numReplaced} document(s).`);
//     //   });
//     // });

//     await applicantRequest(applicantData);
//   } catch (error) {
//     console.log(error);
//     throw error;
//   }
// }
// register("minaShin@gmail.com");

// async function applicantRequest(applicantData: any): Promise<AxiosResponse> {
//   const apiUrl = "https://oapi.greetinghr.com/openapi"; //todo: 환경변수처리
//   const apiKey =
//     "08dacc9b6d4f3ad04f3e31348e1627c69d8883df5eaee04ed3b78a2d8620f65c"; //todo: 환경변수처리
//   return axios.post(`${apiUrl}/applicant`, applicantData, {
//     headers: {
//       "Content-Type": "application/json",
//       "X-Greeting-OpenAPI": `${apiKey}`,
//     },
//   });
// }
